/*
 * SaveState.h
 *
 *  Created on: Oct 17, 2016
 *      Author: josh
 */

#ifndef SOURCE_TECHNICAL_SAVESTATE_H_
#define SOURCE_TECHNICAL_SAVESTATE_H_

#include <string>
#include <vector>

namespace AtomSynth {

/**
 * A structure that can contain numbers,
 * strings, and other SaveState objects,
 * and can be exported to and imported
 * from a single string. Strings, numbers,
 * and SaveState objects are stored
 * independently of each other in seperate
 * vectors. Order is preserved, so they
 * can be accessed in the same order as
 * they were added.
 */
class SaveState {
private:
	std::vector<double> m_values;
	std::vector<std::string> m_strings;
	std::vector<SaveState> m_states;
	int m_nextStateCounter, m_nextValueCounter, m_nextStringCounter;
	/**
	 * Creates a string representing the input, ranging from
	 * 1 to 4 bytes.
	 * @param input The value to convert.
	 * @return A string representing the input.
	 */
	std::string doubleToBytes(double input);
	/**
	 * Takes a string from doubleToBytes() and
	 * converts it back into a double.
	 * @param input A string up to 4 bytes. (Not all bytes will be used, depending on the original value.)
	 * @param bytesUsed This value is overwritten with how many bytes were actually used by the value (anywhere from 1 to 4.)
	 * @return The original double value.
	 */
	double bytesToDouble(std::string input, int& bytesUsed);
	/**
	 * Imports from the old, inefficient string
	 * format.
	 * @param input The string to parse.
	 */
	void importString(std::string input);
	/**
	 * Used by exportBytes()
	 * @return A byte array representing this SaveState.
	 */
	std::string exportBytesBackend();
	/**
	 * Imports from the shiny new bytes format.
	 * @param input A string containing the binary data.
	 */
	void importBytes(std::string input);
	/**
	 * Imports a string containing the shiny new bytes
	 * format encoded with base64.
	 * @param input A string containing the base64-encoded data.
	 */
	void importBase64(std::string input);
public:
	SaveState();
	/**
	 * Construct from an exported string.
	 * @param from A string as generated by exportString()
	 */
	SaveState(std::string from);
	virtual ~SaveState();
	/**
	 * Adds a decimal value to the state.
	 * @param value The value to add.
	 */
	void addValue(double value) {
		m_values.push_back(value);
	}
	/**
	 * Adds a string to the state.
	 * @param string The string to add.
	 */
	void addString(std::string string) {
		m_strings.push_back(string);
	}
	/**
	 * Adds a SaveState object to the state.
	 * @param state The SaveState to add.
	 */
	void addState(SaveState state) {
		m_states.push_back(state);
	}
	/**
	 * Gets a value at a particular index. Any
	 * indexes greater than the bounds of the
	 * list of values will return 0.
	 * @param index The index to retrieve the value from.
	 * @return The value at the index, or 0.
	 */
	double getValue(int index) {
		return (index > m_values.size()) ? 0.0 : m_values[index];
	}
	/**
	 * Gets a string at a particular index. Any
	 * indexes greater than the bounds of the
	 * list of strings will return "".
	 * @param index The index to retrieve the string from.
	 * @return The string at the index, or "".
	 */
	std::string getString(int index) {
		return (index > m_strings.size()) ? "" : m_strings[index];
	}
	/**
	 * Gets a state at a particular index. Any
	 * indexes greater than the bounds of the
	 * list of state will return a blank state.
	 * @param index The index to retrieve the state from.
	 * @return The state at the index, or a blank state.
	 */
	SaveState & getState(int index) {
		return (index > m_states.size()) ? * new SaveState() : m_states[index];
	}
	/**
	 * Use this function repeatedly to extract
	 * all values in order. When this function is
	 * first called, it will return the value at
	 * index 0. The next time it is called, index
	 * 1, and so on. If it reaches the end, it
	 * will wrap around.
	 * @return The value at the next index.
	 */
	double getNextValue();
	/**
	 * Use this function repeatedly to extract
	 * all strings in order. When this function is
	 * first called, it will return the string at
	 * index 0. The next time it is called, index
	 * 1, and so on. If it reaches the end, it
	 * will wrap around.
	 * @return The string at the next index.
	 */
	std::string getNextString();
	/**
	 * Use this function repeatedly to extract
	 * all states in order. When this function is
	 * first called, it will return the state at
	 * index 0. The next time it is called, index
	 * 1, and so on. If it reaches the end, it
	 * will wrap around.
	 * @return The state at the next index.
	 */
	SaveState & getNextState();
	/**
	 * Gets a vector of all values in the
	 * state.
	 * @return A vector of all doubles in the state.
	 */
	std::vector<double> & getValues() {
		return m_values;
	}
	/**
	 * Gets a vector of all strings in the
	 * state.
	 * @return A vector of all strings in the state.
	 */
	std::vector<std::string> & getStrings() {
		return m_strings;
	}
	/**
	 * Gets a vector of all states in the
	 * state.
	 * @return A vector of all states in the state.
	 */
	std::vector<SaveState> & getStates() {
		return m_states;
	}
	/**
	 * Exports the entire content of the state
	 * as a string. Note that this isn't very
	 * space efficient, I might come back to
	 * this and make a binary output format.
	 * @return A string representing the entire state, which can be loaded with a constructor.
	 */
	std::string exportString();
	/**
	 * Exports the entire content of the state
	 * as a byte array. It is a much more efficient
	 * format than what is returned by
	 * exportString().
	 * @return The resulting byte array.
	 */
	std::string exportBytes();
	/**
	 * Exports a copy-pasteable base 64 string
	 * containing the contents of exportBytes().
	 * @return A base 64 string representing the content of exportBytes().
	 */
	std::string exportBase64();
	/**
	 * Dumps the content of this SaveState to the console.
	 * @param extraIndentation Number of extra tabs to add in front of the content.
	 */
	void dumpToConsole(int extraIndentation = 0);
	/**
	 * Prints out how many bytes it would take to
	 * export this SaveState in the old yucky
	 * string format and in the new raw bytes
	 * format. This is purely a vanity function,
	 * it does nothing useful.
	 */
	void showOffNewFormat();
};

} /* namespace AtomSynth */

#endif /* SOURCE_TECHNICAL_SAVESTATE_H_ */
